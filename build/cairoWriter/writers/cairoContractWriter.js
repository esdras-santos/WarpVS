"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CairoContractWriter = void 0;
const solc_typed_ast_1 = require("solc-typed-ast");
const utils_1 = require("../../utils/utils");
const cairoNodes_1 = require("../../ast/cairoNodes");
const nameModifiers_1 = require("../../utils/nameModifiers");
const base_1 = require("../base");
const utils_2 = require("../utils");
const sourceUnitWriter_1 = require("./sourceUnitWriter");
const freeStructWritter_1 = require("../../freeStructWritter");
const assert_1 = __importDefault(require("assert"));
const endent_1 = __importDefault(require("endent"));
class CairoContractWriter extends base_1.CairoASTNodeWriter {
    writeInner(node, writer) {
        if (node.kind === solc_typed_ast_1.ContractKind.Interface) {
            return this.writeContractInterface(node, writer);
        }
        if (node.abstract)
            return [
                `// This contract may be abstract, it may not implement an abstract parent's methods\n// completely or it may not invoke an inherited contract's constructor correctly.\n`,
            ];
        const dynamicVariables = [...node.dynamicStorageAllocations.entries()].map(([decl, loc]) => `const ${decl.name}: felt252 = ${loc};`);
        const staticVariables = [...node.staticStorageAllocations.entries()].map(([decl, loc]) => `const ${decl.name}: felt252 = ${loc};`);
        const variables = [
            `// Dynamic variables - Arrays and Maps`,
            ...dynamicVariables,
            `// Static variables`,
            ...staticVariables,
        ];
        let documentation = (0, utils_2.getDocumentation)(node.documentation, writer);
        if (documentation.slice(2).trim().startsWith('warp-cairo')) {
            documentation = documentation
                .split('\n')
                .map((line) => line.slice(2))
                .slice(1)
                .join('\n');
        }
        // Don't need to write structs, SourceUnitWriter does so already
        const enums = node.vEnums.map((value) => writer.write(value));
        const externalFunctions = node.vFunctions
            .filter((func) => (0, utils_1.isExternallyVisible)(func))
            .map((func) => writer.write(func));
        const otherFunctions = node.vFunctions
            .filter((func) => !(0, utils_1.isExternallyVisible)(func))
            .map((func) => writer.write(func));
        const events = node.vEvents.map((value) => writer.write(value)).join('\n\n');
        const body = [...variables, ...enums, ...otherFunctions]
            .join('\n\n')
            .split('\n')
            .map((l) => (l.length > 0 ? utils_2.INDENT + l : l))
            .join('\n');
        const outsideNamespaceBody = [...externalFunctions]
            .join('\n\n')
            .split('\n')
            .map((l) => (l.length > 0 ? utils_2.INDENT + l : l))
            .join('\n');
        const sourceUnit = node.parent;
        (0, assert_1.default)(sourceUnit instanceof solc_typed_ast_1.SourceUnit, 'Contract node parent should be a Source Unit node.');
        const otherStorageVars = sourceUnit.vFunctions.filter((v) => v instanceof cairoNodes_1.CairoGeneratedFunctionDefinition &&
            v.functionStubKind === cairoNodes_1.FunctionStubKind.StorageDefStub);
        const storageCode = (0, endent_1.default) `
      struct Storage {
        WARP_STORAGE: LegacyMap::<felt252, felt252>,
        WARP_USED_STORAGE: felt252,
        WARP_NAMEGEN: felt252,
        ${otherStorageVars.map((v) => `${writer.write(v)}`).join('\n')}
      }

      fn readId(loc: felt252) -> felt252 {
        let id = WARP_STORAGE::read(loc);
        if id == 0 {
          let id = WARP_NAMEGEN::read();
          WARP_NAMEGEN::write(id + 1);
          WARP_STORAGE::write(loc, id + 1);
          return id + 1;
        } 
        return id;
      }
    `;
        // Data about imports used, util funcs, constants and structs definition are stored in the Source Unit node
        // but should be printed inside the contract module
        // Only constants generated by `newToDeploy` exist at this stage
        const constants = sourceUnit.vVariables
            .map((v) => {
            (0, assert_1.default)(v.vValue !== undefined, 'Constants cannot be unanssigned');
            return [`// ${v.documentation}`, `const ${v.name} = ${writer.write(v.vValue)};`].join('\n');
        })
            .join('\n');
        const freeStructs = (0, freeStructWritter_1.getStructs)(sourceUnit);
        const structs = [...freeStructs, ...sourceUnit.vStructs, ...(node?.vStructs || [])]
            .map((v) => writer.write(v))
            .join('\n\n');
        const importFunctions = sourceUnit.vFunctions.filter((f) => f instanceof cairoNodes_1.CairoImportFunctionDefinition);
        const generatedFunctions = sourceUnit.vFunctions.filter((f) => f instanceof cairoNodes_1.CairoGeneratedFunctionDefinition);
        const otherSourceUnitFunctions = sourceUnit.vFunctions.filter((f) => !(f instanceof cairoNodes_1.CairoGeneratedFunctionDefinition) &&
            !(f instanceof cairoNodes_1.CairoImportFunctionDefinition));
        const writtenImportFuncs = importFunctions
            .map((n) => writer.write(n))
            .sort((importA, importB) => importA.localeCompare(importB))
            .filter((func, index, importFuncs) => func !== importFuncs[index - 1])
            .join('\n');
        const writtenGeneratedFuncs = generatedFunctions
            .sort((funcA, funcB) => funcA.name.localeCompare(funcB.name))
            .sort((funcA, funcB) => {
            const stubA = funcA.functionStubKind;
            const stubB = funcB.functionStubKind;
            if (stubA === stubB)
                return 0;
            if (stubA === cairoNodes_1.FunctionStubKind.StructDefStub)
                return -1;
            if (stubA === cairoNodes_1.FunctionStubKind.StorageDefStub)
                return -1;
            return 1;
        })
            .filter((func, index, genFuncs) => func.name !== genFuncs[index - 1]?.name &&
            func.functionStubKind !== cairoNodes_1.FunctionStubKind.StorageDefStub)
            .map((func) => writer.write(func))
            .join('\n\n');
        const writtenOtherSourceUnitFunctions = otherSourceUnitFunctions
            .map((func) => writer.write(func))
            .join('\n\n');
        const contractHeader = '#[contract] \n' + `mod ${node.name} {`;
        return [
            [
                contractHeader,
                documentation,
                writtenImportFuncs,
                constants,
                storageCode,
                events,
                structs,
                body,
                outsideNamespaceBody,
                writtenGeneratedFuncs,
                writtenOtherSourceUnitFunctions,
                `}`,
            ].join('\n\n'),
        ];
    }
    writeWhole(node, writer) {
        return [`${this.writeInner(node, writer)}`];
    }
    writeContractInterface(node, writer) {
        const documentation = (0, utils_2.getDocumentation)(node.documentation, writer);
        const functions = node.vFunctions.map((v) => {
            const resultLines = writer
                .write(v)
                /* TODO: It's a quickfix for now. Implement that as a pass maybe.
                       Remove any StructuredDocumentation from interface's functions?
                       Only those that start with 'warp-cairo'?
                       Or create a pass that transforms StructuredDocumentation into AST nodes and removes the function body from interfaces?
              */
                .replace(/\s*\/\/.*/g, '')
                // remove all content between any two pairing curly braces
                .replace(/\{[^]*\}/g, '')
                .split('\n');
            const funcLineIndex = resultLines.findIndex((line) => line.startsWith('func'));
            resultLines.splice(0, funcLineIndex);
            return resultLines.join('\n') + '{\n}';
        });
        // Handle the workaround of genContractInterface function of externalContractInterfaceInserter.ts
        // Remove `@interface` to get the actual contract interface name
        const interfaceName = node.name.endsWith(nameModifiers_1.TEMP_INTERFACE_SUFFIX)
            ? (0, utils_2.getInterfaceNameForContract)(node.name.replace(nameModifiers_1.TEMP_INTERFACE_SUFFIX, ''), node, sourceUnitWriter_1.interfaceNameMappings)
            : node.name;
        return [
            [
                documentation,
                [`@contract_interface`, `namespace ${interfaceName}{`, ...functions, `}`].join('\n'),
            ].join('\n'),
        ];
    }
}
exports.CairoContractWriter = CairoContractWriter;
//# sourceMappingURL=cairoContractWriter.js.map